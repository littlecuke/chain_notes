###memory & storage & calldata 


#### 引用类型
引用类型可以通过多个不同的名称修改它的值，而值类型的变量，每次都有独立的副本。因此，必须比值类型更谨慎地处理引用类型。 目前，引用类型包括结构，数组和映射，如果使用引用类型，则必须明确指明数据存储哪种类型的位置（空间）里

*	内存（memory） 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用
*	存储storage 状态变量保存的位置，只要合约存在就一直存储．
*	调用数据calldata 用来保存函数参数的特殊数据位置，是一个只读位置
	```
	0.6.9 之前 calldata 仅用于外部函数调用参数，0.6.9之后可用于任意函数。
	
	```
更改数据位置或类型转换将始终产生自动进行一份拷贝，而在同一数据位置内（对于 存储storage 来说）的复制仅在某些情况下进行拷贝。

####数据位置

所有的引用类型，如 <font color="red">数组</font> 和 <font color="red">结构体 </font>类型，都有一个额外注解 [ 数据位置 ] ，来说明数据存储位置。 有三种位置： 内存memory 、 存储storage 以及 调用数据calldata 。调用数据calldata 是不可修改的、非持久的函数参数存储区域，效果大多类似 内存memory 。
调用数据calldata 是外部函数的参数所必需指定的位置，但也可以用于其他变量。
	```
	在版本0.5.0之前，数据位置可以省略，并且根据变量的类型，函数类型等有默认数据位置，但是所有复杂类型现在必须提供明确的数据位置。

	如果可以的话，请尽量使用 calldata 作为数据位置，因为它将避免复制，并确保不能修改数据。 函数的返回值中也可以使用 calldata 数据位置的数组和结构，但是无法给其分配空间。

	```

####数据位置与赋值行为

数据位置不仅仅表示数据如何保存，它同样影响着赋值行为：

*	在 存储storage 和 内存memory 之间两两赋值（或者从 调用数据calldata 赋值 ），都会创建一份独立的拷贝。
*	从 内存memory 到 内存memory 的赋值只创建引用， 这意味着更改内存变量，其他引用相同数据的所有其他内存变量的值也会跟着改变。
*	从 存储storage 到本地存储变量的赋值也只分配一个引用。
*	其他的向 存储storage 的赋值，总是进行拷贝。 这种情况的示例如对状态变量或 存储storage 的结构体类型的局部变量成员的赋值，即使局部变量本身是一个引用，也会进行一份拷贝（译者注：查看下面 ArrayContract 合约 更容易理解）。

####数组
数组可以在声明时指定长度，也可以动态调整大小（长度）。
数组下标是从 0 开始的，且访问数组时的下标顺序与声明时相反。
```
如：如果有一个变量为 uint[][5] memory x， 要访问第三个动态数组的第二个元素，使用 x[2][1]，要访问第三个动态数组使用 x[2]。
同样，如果有一个 T 类型的数组 T[5] a ， T 也可以是一个数组，那么 a[2] 总会是 T 类型。

```

数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在 <font color="red">[存储storage]</font> 中，并且公开访问函数的参数需要是 ABI 类型。( 应用二进制接口)

状态变量标记 public 的数组，Solidity创建一个 getter函数 。 小标数字索引就是 getter函数 的参数。

访问超出数组长度的元素会导致异常（assert 类型异常 ）。 可以使用 .push() 方法在末尾追加一个新元素，其中 .push() 追加一个零初始化的元素并返回对它的引用。

####bytes & strings

bytes 和 string 类型的变量是特殊的数组。 bytes 类似于 byte[]，但它在 调用数据calldata 和 内存memory 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。 string 与 bytes 相同，但不允许用长度或索引来访问。

我们更多时候应该使用 bytes 而不是 byte[] ，因为Gas 费用更低, byte[] 会在元素之间添加31个填充字节。作为一个基本规则， 对任意长度的原始字节数据使用 bytes，对任意长度字符串（UTF-8）数据使用 string。

如果使用一个长度限制的字节数组，应该使用一个 bytes1 到 bytes32 的具体类型，因为它们便宜得多。


如果想要访问以字节表示的字符串 s，请使用 bytes(s).length / bytes(s)[7] = 'x';。 注意这时你访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。

####数组字面常量 / 内联数组

数组字面常量是在方括号中（ [...] ） 包含一个或多个逗号分隔的表达式。 例如 [1, a, f(3)] 。 必须有一个所有元素都可以隐式转换到普通的类型，这个类型就是数组的基本类型。 数组字面常量总是静态固定大小的 内存memory 数组。
目前需要注意的是，定长的 内存memory 数组并不能赋值给变长的 内存memory 数组，下面的例子是无法运行的：
```
// 这段代码并不能编译。

pragma solidity  >=0.4.0 <0.9.0;

contract LBC {
    function f() public {
        // 这一行引发了一个类型错误，因为 unint[3] memory
        // 不能转换成 uint[] memory。
        uint[] x = [uint(1), 3, 4];
    }
}

```

####数组成员

*	length:
	数组有 length 成员变量表示当前数组的长度。 一经创建，内存memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。
*	push():
	动态的 存储storage 数组以及 bytes 类型（ string 类型不可以）都有一个 push() 的成员函数，它用来添加新的零初始化元素到数组末尾，并返回元素引用． 因此可以这样：　 x.push().t = 2 或 x.push() = b.
*	push(x):
	动态的 存储storage 数组以及 bytes 类型（ string 类型不可以）都有一个 push(ｘ) 的成员函数，用来在数组末尾添加一个给定的元素，这个函数没有返回值．
*	pop:
	变长的 存储storage 数组以及 bytes 类型（ string 类型不可以）都有一个 pop 的成员函数， 它用来从数组末尾删除元素。 同样的会在移除的元素上隐含调用 delete 
```
通过 push()　增加 存储storage 数组的长度具有固定的 gas 消耗，因为 存储storage 总是被零初始化，而通过　pop　减少长度则依赖移除与元素的大小（size）．　如果元素是数组,则成本是很高的,因为它包括已删除的元素的清理，类似于在这些元素上调用 delete 。

如果需要在外部（external）函数中使用多维数组，这需要启用ABI coder v2。 公有（public）函数中是支持的使用多维数组。

在Byzantium（在2017-10-16日4370000区块上进行硬分叉升级）之前的EVM版本中，无法访问从函数调用返回动态数组。 如果要调用返回动态数组的函数，请确保 EVM 在拜占庭模式上运行。

```






